/* Copyright 2015 Samsung Electronics Co., LTD
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.gearvrf;

import org.gearvrf.utility.ResourceCache;
import org.joml.Matrix4f;
import org.joml.Vector4f;

import java.util.HashMap;

/**
 * Causes a shadow map to be rendered from the viewpoint
 * of the scene object which owns the shadow map.
 * A shadow map is only rendered if a light is
 * attached to the owning scene object.
 * All of the shadow maps are kept in a single
 * texture array and they must all be the same size.
 * This array is created the first time a GVRShadowMap
 * component is created.
 * @see GVRRenderTarget
 * @see GVRRenderTextureArray
 */
public class GVRShadowMap extends GVRRenderTarget
{
    /**
     * When the application is restarted we recreate the render texture array
     * since all of the GL textures have been deleted.
     */
    static
    {
        GVRContext.addResetOnRestartHandler(new Runnable()
        {
            @Override
            public void run()
            {
                sShadowMaps = null;
                sShadowMaterial = null;
            }
        });
    }

    /**
     * Constructs a shadow map using the given material.
     *
     * @param ctx GVRContext to associate the shadow map with.
     */
    public GVRShadowMap(GVRContext ctx)
    {
        super(ctx, NativeShadowMap.ctor(getShadowMaterial(ctx).getNative()));
        mShadowMatrix = new Matrix4f();
        mTemp = new Vector4f();
        mTempMtx = new float[16];
        if (sShadowMaps == null)
        {
            sShadowMaps = new GVRRenderTextureArray(ctx, 1024, 1024, 2, 4);
            sBiasMatrix = new Matrix4f();
            sBiasMatrix.scale(0.5f);
            sBiasMatrix.setTranslation(0.5f, 0.5f, 0.5f);
        }
        setTexture(sShadowMaps);
    }

    /**
     * Adds an orthographic camera constructed from the designated
     * perspective camera to describe the shadow projection.
     * The field of view and aspect ration of the perspective
     * camera are used to obtain the view volume of the
     * orthographic camera. This type of camera is used
     * for shadows generated by direct lights at infinite distance.
     * @param centerCam GVRPerspectiveCamera to derive shadow projection from
     * @see GVRDirectLight
     */
    public void addOrthoShadowCamera(GVRPerspectiveCamera centerCam)
    {
        GVROrthogonalCamera shadowCam = new GVROrthogonalCamera(getGVRContext());
        float near = sShadowMaterial.hasUniform("shadow_near") ? sShadowMaterial.getFloat("shadow_near") : centerCam.getNearClippingDistance();
        float far = sShadowMaterial.hasUniform("shadow_far") ? sShadowMaterial.getFloat("shadow_far") : centerCam.getFarClippingDistance();
        float fovy = (float) Math.toRadians(centerCam.getFovY());
        float h = (float) (Math.atan(fovy / 2.0f) * far) / 2.0f;

        shadowCam.setLeftClippingDistance(-h);
        shadowCam.setRightClippingDistance(h);
        shadowCam.setTopClippingDistance(h);
        shadowCam.setBottomClippingDistance(-h);
        shadowCam.setNearClippingDistance(near);
        shadowCam.setFarClippingDistance(far);
        setCamera(shadowCam);
    }

    /**
     * Adds a perspective camera constructed from the designated
     * perspective camera to describe the shadow projection.
     * This type of camera is used for shadows generated by spot lights.
     * @param centerCam GVRPerspectiveCamera to derive shadow projection from
     * @param coneAngle spot light cone angle
     * @see GVRSpotLight
     */
    public void addPerspShadowCamera(GVRPerspectiveCamera centerCam, float coneAngle)
    {
        GVRPerspectiveCamera camera = new GVRPerspectiveCamera(getGVRContext());
        GVRMaterial mtl = GVRLightBase.getShadowMaterial(getGVRContext());
        float near = sShadowMaterial.hasUniform("shadow_near") ? sShadowMaterial.getFloat("shadow_near") : centerCam.getNearClippingDistance();
        float far = sShadowMaterial.hasUniform("shadow_far") ? sShadowMaterial.getFloat("shadow_far") : centerCam.getFarClippingDistance();

        camera.setNearClippingDistance(near);
        camera.setFarClippingDistance(far);
        camera.setFovY((float) Math.toDegrees(coneAngle));
        camera.setAspectRatio(1.0f);
        setCamera(camera);
    }

    /**
     * Sets the shadow matrix for the spot light from the input model/view
     * matrix and the shadow camera projection matrix.
     * @param modelView light model/view transform
     * @param light     spot light component to update
     */
    public void setPerspShadowMatrix(Matrix4f modelView, GVRLightBase light)
    {
        GVRPerspectiveCamera camera = (GVRPerspectiveCamera) getCamera();

        if (camera == null)
        {
            return;
        }
        float angle = (float) Math.acos(light.getFloat("outer_cone_angle")) * 2.0f;

        modelView.invert();
        modelView.get(mTempMtx);
        camera.setViewMatrix(mTempMtx);
        camera.setFovY((float) Math.toDegrees(angle));
        mShadowMatrix.setPerspective(angle, 1.0f, camera.getNearClippingDistance(), camera.getFarClippingDistance());
        mShadowMatrix.mul(modelView);
        sBiasMatrix.mul(mShadowMatrix, mShadowMatrix);
        mShadowMatrix.getColumn(0, mTemp);
        light.setVec4("sm0", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(1, mTemp);
        light.setVec4("sm1", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(2, mTemp);
        light.setVec4("sm2", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(3, mTemp);
        light.setVec4("sm3", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
    }

    /**
     * Sets the direct light shadow matrix for the light from the input model/view
     * matrix and the shadow camera projection matrix.
     * @param modelView light model/view transform
     * @param light     direct light component to update
     */
    public void setOrthoShadowMatrix(Matrix4f modelView, GVRLightBase light)
    {
        GVROrthogonalCamera camera = (GVROrthogonalCamera) getCamera();
        if (camera == null)
        {
            return;
        }

        float w = camera.getRightClippingDistance() - camera.getLeftClippingDistance();
        float h = camera.getTopClippingDistance() - camera.getBottomClippingDistance();
        float near = camera.getNearClippingDistance();
        float far = camera.getFarClippingDistance();

        modelView.invert();
        modelView.get(mTempMtx);
        camera.setViewMatrix(mTempMtx);
        mShadowMatrix.setOrthoSymmetric(w, h, near, far);
        mShadowMatrix.mul(modelView);
        sBiasMatrix.mul(mShadowMatrix, mShadowMatrix);
        mShadowMatrix.getColumn(0, mTemp);
        light.setVec4("sm0", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(1, mTemp);
        light.setVec4("sm1", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(2, mTemp);
        light.setVec4("sm2", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
        mShadowMatrix.getColumn(3, mTemp);
        light.setVec4("sm3", mTemp.x, mTemp.y, mTemp.z, mTemp.w);
    }

    /**
     * Gets the shadow material used in constructing shadow maps.
     *
     * @return shadow map material
     */
    static GVRMaterial getShadowMaterial(GVRContext ctx)
    {
        if (sShadowMaterial == null)
        {
            sShadowMaterial = new GVRMaterial(ctx, new GVRShaderId(GVRDepthShader.class));
        }
        return sShadowMaterial;
    }

    protected Matrix4f mShadowMatrix;
    protected Vector4f mTemp;
    protected float[] mTempMtx;
    static Matrix4f sBiasMatrix = null;
    static GVRRenderTextureArray sShadowMaps = null;
    static GVRMaterial sShadowMaterial = null;
}

class NativeShadowMap
{
    static native long ctor(long material);
}